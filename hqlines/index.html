<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">

    <!-- Enable responsiveness on mobile devices-->
    <!-- viewport-fit=cover is to support iPhone X rounded corners and notch in landscape-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, viewport-fit=cover">

    <title>Vlad Jukov&#x27;s blog</title>

    <!-- CSS -->
    
    <link rel="stylesheet" href="https:&#x2F;&#x2F;vladjuckov.github.io&#x2F;colors-dark.css">
    
    

    

    
    
  </head>
  <body>
    <header id="header">
      <h1><a href="https:&#x2F;&#x2F;vladjuckov.github.io&#x2F;">Vlad Jukov&#x27;s blog</a></h1>
      <p>About graphics programming</p>
    </header>
    <div id="page">
      <div id="sidebar">
        
          
        
      </div>
      <div id="content">
        
<article class="post">
  <h1><a href="https:&#x2F;&#x2F;vladjuckov.github.io&#x2F;hqlines&#x2F;">Is it easy to draw a line</a></h1>

  <div class="post-content"><!-- ![lines_square](lines_square.jpg) -->
<p><a href="https://pum-purum-pum-pum.github.io/lines/">Demo</a>
Note that for some reason on the web
it's not that good as on the desktop (mb I'll write another note later).
I also had to turn off browser's AA manually.</p>
<p><a href="https://github.com/pum-purum-pum-pum/Lines">Source code</a></p>
<h3 id="wait-what">Wait what?</h3>
<p>If you just draw rectangle in OpenGL you'll
notice that the edges look like a pixel ladder.
You may try to fix that with MSAA but its still will be poor quality.
Also one may want to draw the line not as a rectangle but as a rounded rectangle.</p>
<p><img src="https://vladjuckov.github.io/hqlines/line.gif" alt="line" />
<a href="https://www.displaydaily.com/?view=article&amp;id=102:antialiasing&amp;catid=118:word-of-the-week">picture reference</a></p>
<h3 id="normal-width">Normal + width</h3>
<p>To draw just rectangle lines one can use normal to a segment as a vertex attribute.
This approach is well described <a href="https://blog.mapbox.com/drawing-antialiased-lines-with-opengl-8766f34192dc">here</a></p>
<h3 id="sdf">SDF</h3>
<p>The other way of drawing high quality segments is using Signed Distance Field (SDF).
That is what I'm using in my game
<img src="https://vladjuckov.github.io/hqlines/lines_hexstrat.png" alt="hex_strat" />
We can create smooth edges by calculating the distance to it
(we assume here that there is no thickness of the line).
Also, with SDF we can create a nice rounded segment's ends.</p>
<p>We also can use that for drawing polygonal chains.
(correct me if there is simpler term for this).
Unfortunately, we can't just draw these segments on the top of each other,
because of transparent edges that will overlap and create ugly blending effect.
Or if the line itself is transparent we will just see overlaps.
It can be solved with rendering to texture for example.</p>
<p>We will only consider opaque polygonal chains next.
(again we can render to texture and then do transparent chains).</p>
<p><a href="https://www.shadertoy.com/view/Wlfyzl">Here</a>
is the shader we will use for the segment's SDF.</p>
<pre style="background-color:#002b36;">
<span style="color:#839496;">float </span><span style="color:#859900;">line_segment</span><span style="color:#839496;">(</span><span style="color:#859900;">in</span><span style="color:#839496;"> vec2 p, </span><span style="color:#859900;">in</span><span style="color:#839496;"> vec2 a, </span><span style="color:#859900;">in</span><span style="color:#839496;"> vec2 b) {
    vec2 ba </span><span style="color:#859900;">=</span><span style="color:#839496;"> b </span><span style="color:#859900;">-</span><span style="color:#839496;"> a;
    vec2 pa </span><span style="color:#859900;">=</span><span style="color:#839496;"> p </span><span style="color:#859900;">-</span><span style="color:#839496;"> a;
    float h </span><span style="color:#859900;">= clamp</span><span style="color:#839496;">(</span><span style="color:#859900;">dot</span><span style="color:#839496;">(pa, ba) </span><span style="color:#859900;">/ dot</span><span style="color:#839496;">(ba, ba), </span><span style="color:#6c71c4;">0.</span><span style="color:#839496;">, </span><span style="color:#6c71c4;">1.</span><span style="color:#839496;">);
    </span><span style="color:#859900;">return length</span><span style="color:#839496;">(pa </span><span style="color:#859900;">-</span><span style="color:#839496;"> h </span><span style="color:#859900;">*</span><span style="color:#839496;"> ba);
}
</span><span style="color:#859900;">...
</span><span style="color:#586e75;">// later used like
</span><span style="color:#839496;">lowp float distance </span><span style="color:#859900;">= line_segment</span><span style="color:#839496;">(pp, a, b) </span><span style="color:#859900;">-</span><span style="color:#839496;"> thickness;
</span></pre>
<p>As you can see in fragment shader we need to have segment's ends and thickness.
We just pass these parameters as vertex attributes in the vertex
shader and then into fragment shader.
There are two ways that come to my head to do this:</p>
<ol>
<li>Create a buffer with two triangles for each line.
Just pass SDF parameters in each Vertex.</li>
<li>Only create one buffer for a line with two triangles and pass
these parameters per line via instancing.</li>
</ol>
<p>Our line struct will look like this. (segment type is actually discrete value)</p>
<pre style="background-color:#002b36;">
<span style="color:#839496;">#[</span><span style="color:#268bd2;">derive</span><span style="color:#839496;">(Debug, Clone, Copy)]
#[</span><span style="color:#268bd2;">repr</span><span style="color:#839496;">(C)]
</span><span style="color:#859900;">pub </span><span style="color:#268bd2;">struct </span><span style="color:#839496;">Line {
    </span><span style="color:#859900;">pub </span><span style="color:#268bd2;">segment_type</span><span style="color:#839496;">: </span><span style="color:#268bd2;">f32</span><span style="color:#839496;">,
    </span><span style="color:#859900;">pub </span><span style="color:#268bd2;">position</span><span style="color:#839496;">: Vec2,
    </span><span style="color:#859900;">pub </span><span style="color:#268bd2;">thickness</span><span style="color:#839496;">: </span><span style="color:#268bd2;">f32</span><span style="color:#839496;">,
    </span><span style="color:#859900;">pub </span><span style="color:#268bd2;">dir</span><span style="color:#839496;">: Vec2,
    </span><span style="color:#859900;">pub </span><span style="color:#268bd2;">color</span><span style="color:#839496;">: Vec3,
}

</span><span style="color:#268bd2;">impl </span><span style="color:#839496;">Line {
    </span><span style="color:#859900;">pub </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">new</span><span style="color:#839496;">(
        </span><span style="color:#268bd2;">segment_type</span><span style="color:#839496;">: SegmentType,
        </span><span style="color:#268bd2;">from</span><span style="color:#839496;">: Vec2,
        </span><span style="color:#268bd2;">to</span><span style="color:#839496;">: Vec2,
        </span><span style="color:#268bd2;">thickness</span><span style="color:#839496;">: </span><span style="color:#268bd2;">f32</span><span style="color:#839496;">,
        </span><span style="color:#268bd2;">color</span><span style="color:#839496;">: Vec3,
    ) -&gt; </span><span style="color:#268bd2;">Self </span><span style="color:#839496;">{
        </span><span style="color:#268bd2;">let</span><span style="color:#839496;"> dir </span><span style="color:#859900;">=</span><span style="color:#839496;"> to </span><span style="color:#859900;">-</span><span style="color:#839496;"> from;
        Line {
            segment_type: segment_type </span><span style="color:#859900;">as </span><span style="color:#268bd2;">u8 </span><span style="color:#859900;">as </span><span style="color:#268bd2;">f32</span><span style="color:#839496;">, </span><span style="color:#586e75;">// dirty hack to make OpenGL happy
</span><span style="color:#839496;">            position: (from </span><span style="color:#859900;">+</span><span style="color:#839496;"> to) </span><span style="color:#859900;">/ </span><span style="color:#6c71c4;">2.</span><span style="color:#839496;">,
            thickness,
            dir,
            color,
        }
    }
}
</span></pre><h3 id="shaders">Shaders</h3>
<p>I'm not sure if the second way is faster
(since the instance is only two triangles --
the overhead is small).
But it's convenient and fast enough
to draw million of antialiased high-quality lines.</p>
<p>Here is the vertex shader code (sorry for the old glsl version):</p>
<pre style="background-color:#002b36;">
<span style="color:#839496;">#version </span><span style="color:#6c71c4;">100</span><span style="color:#839496;">
precision lowp </span><span style="color:#268bd2;">float</span><span style="color:#839496;">;
attribute vec2 pos;
attribute </span><span style="color:#268bd2;">float</span><span style="color:#839496;"> segment_type;
attribute vec2 inst_pos;
attribute </span><span style="color:#268bd2;">float</span><span style="color:#839496;"> thickness;
attribute vec2 dir;
attribute vec3 color0;

varying vec2 local_position;
varying vec2 projected_position;
varying vec2 ip;
varying </span><span style="color:#268bd2;">float</span><span style="color:#839496;"> th;
varying vec4 color;
</span><span style="color:#586e75;">// segment type. Have to pass as float, but it is just enum
</span><span style="color:#839496;">varying </span><span style="color:#268bd2;">float</span><span style="color:#839496;"> st;
varying vec2 dr;

uniform mat4 mvp;
</span><span style="color:#268bd2;">void </span><span style="color:#b58900;">main</span><span style="color:#839496;">() {
    vec2 n </span><span style="color:#657b83;">= </span><span style="color:#268bd2;">vec2</span><span style="color:#839496;">(</span><span style="color:#657b83;">-</span><span style="color:#839496;">dir.</span><span style="color:#268bd2;">y</span><span style="color:#839496;">, dir.</span><span style="color:#268bd2;">x</span><span style="color:#839496;">) </span><span style="color:#657b83;">/ </span><span style="color:#268bd2;">length</span><span style="color:#839496;">(dir);
    vec2 apos </span><span style="color:#657b83;">=</span><span style="color:#839496;"> pos.</span><span style="color:#268bd2;">y </span><span style="color:#859900;">*</span><span style="color:#839496;"> dir </span><span style="color:#657b83;">+</span><span style="color:#839496;"> pos.</span><span style="color:#268bd2;">x </span><span style="color:#859900;">*</span><span style="color:#839496;"> n </span><span style="color:#859900;">*</span><span style="color:#839496;"> thickness;
    vec4 new_pos </span><span style="color:#657b83;">= </span><span style="color:#268bd2;">vec4</span><span style="color:#839496;">(apos </span><span style="color:#657b83;">+</span><span style="color:#839496;"> inst_pos, </span><span style="color:#6c71c4;">0.0</span><span style="color:#839496;">, </span><span style="color:#6c71c4;">1.0</span><span style="color:#839496;">);
    vec4 res_pos </span><span style="color:#657b83;">=</span><span style="color:#839496;"> mvp </span><span style="color:#859900;">*</span><span style="color:#839496;"> new_pos;
    gl_Position </span><span style="color:#657b83;">=</span><span style="color:#839496;"> res_pos;

    st </span><span style="color:#657b83;">=</span><span style="color:#839496;"> segment_type;
    local_position </span><span style="color:#657b83;">=</span><span style="color:#839496;"> pos;
    projected_position </span><span style="color:#657b83;">= </span><span style="color:#268bd2;">vec2</span><span style="color:#839496;">(new_pos.</span><span style="color:#268bd2;">x</span><span style="color:#839496;">, new_pos.</span><span style="color:#268bd2;">y</span><span style="color:#839496;">);
    ip </span><span style="color:#657b83;">=</span><span style="color:#839496;"> inst_pos;
    dr </span><span style="color:#657b83;">=</span><span style="color:#839496;"> dir;
    th </span><span style="color:#657b83;">=</span><span style="color:#839496;"> thickness;
    color </span><span style="color:#657b83;">= </span><span style="color:#268bd2;">vec4</span><span style="color:#839496;">(color0, </span><span style="color:#6c71c4;">0.5</span><span style="color:#839496;">);
}
</span></pre>
<p>We just change the shape of our line according to these parameters:</p>
<ul>
<li>dir: segment direction</li>
<li>thickness: thickness of the line</li>
</ul>
<p>and then pass required variables into the fragment shader</p>
<p>Here is the fragment shader:</p>
<pre style="background-color:#002b36;">
<span style="color:#839496;">#version </span><span style="color:#6c71c4;">100</span><span style="color:#839496;">
precision lowp </span><span style="color:#268bd2;">float</span><span style="color:#839496;">;
varying vec2 local_position;
varying vec2 projected_position;
varying vec2 ip;
varying </span><span style="color:#268bd2;">float</span><span style="color:#839496;"> th;
varying vec4 color;
varying </span><span style="color:#268bd2;">float</span><span style="color:#839496;"> st;
varying vec2 dr;

uniform mat4 mvp;
</span><span style="color:#859900;">const</span><span style="color:#839496;"> lowp </span><span style="color:#268bd2;">float</span><span style="color:#839496;"> aaborder </span><span style="color:#657b83;">= </span><span style="color:#6c71c4;">0.00445</span><span style="color:#839496;">;

</span><span style="color:#268bd2;">float </span><span style="color:#b58900;">line_segment</span><span style="color:#839496;">(in vec2 </span><span style="color:#268bd2;">p</span><span style="color:#839496;">, in vec2 </span><span style="color:#268bd2;">a</span><span style="color:#839496;">, in vec2 </span><span style="color:#268bd2;">b</span><span style="color:#839496;">) {
    vec2 ba </span><span style="color:#657b83;">=</span><span style="color:#839496;"> b </span><span style="color:#657b83;">-</span><span style="color:#839496;"> a;
    vec2 pa </span><span style="color:#657b83;">=</span><span style="color:#839496;"> p </span><span style="color:#657b83;">-</span><span style="color:#839496;"> a;
    </span><span style="color:#268bd2;">float</span><span style="color:#839496;"> h </span><span style="color:#657b83;">= </span><span style="color:#268bd2;">clamp</span><span style="color:#839496;">(</span><span style="color:#268bd2;">dot</span><span style="color:#839496;">(pa, ba) </span><span style="color:#657b83;">/ </span><span style="color:#268bd2;">dot</span><span style="color:#839496;">(ba, ba), </span><span style="color:#6c71c4;">0.</span><span style="color:#839496;">, </span><span style="color:#6c71c4;">1.</span><span style="color:#839496;">);
    </span><span style="color:#859900;">return </span><span style="color:#268bd2;">length</span><span style="color:#839496;">(pa </span><span style="color:#657b83;">-</span><span style="color:#839496;"> h </span><span style="color:#859900;">*</span><span style="color:#839496;"> ba);
}

</span><span style="color:#268bd2;">void </span><span style="color:#b58900;">main</span><span style="color:#839496;">() {
    vec2 a </span><span style="color:#657b83;">=</span><span style="color:#839496;"> ip </span><span style="color:#657b83;">-</span><span style="color:#839496;"> dr  </span><span style="color:#657b83;">/ </span><span style="color:#6c71c4;">2.</span><span style="color:#839496;">;
    vec2 b </span><span style="color:#657b83;">=</span><span style="color:#839496;"> ip </span><span style="color:#657b83;">+</span><span style="color:#839496;"> dr </span><span style="color:#657b83;">/ </span><span style="color:#6c71c4;">2.</span><span style="color:#839496;">;
    </span><span style="color:#268bd2;">float</span><span style="color:#839496;"> d </span><span style="color:#657b83;">= </span><span style="color:#268bd2;">line_segment</span><span style="color:#839496;">(projected_position, a, b) </span><span style="color:#657b83;">-</span><span style="color:#839496;"> th;
    </span><span style="color:#268bd2;">float</span><span style="color:#839496;"> scaled_border </span><span style="color:#657b83;">=</span><span style="color:#839496;"> aaborder </span><span style="color:#657b83;">/</span><span style="color:#839496;"> mvp[</span><span style="color:#6c71c4;">1</span><span style="color:#839496;">][</span><span style="color:#6c71c4;">1</span><span style="color:#839496;">];
    </span><span style="color:#268bd2;">float</span><span style="color:#839496;"> edge1 </span><span style="color:#657b83;">= -</span><span style="color:#839496;">scaled_border;
    </span><span style="color:#268bd2;">float</span><span style="color:#839496;"> edge2 </span><span style="color:#657b83;">= </span><span style="color:#6c71c4;">0.</span><span style="color:#839496;">;

    </span><span style="color:#859900;">if </span><span style="color:#839496;">(d </span><span style="color:#657b83;">&lt; </span><span style="color:#6c71c4;">0.</span><span style="color:#839496;">) {
        </span><span style="color:#268bd2;">float</span><span style="color:#839496;"> smooth </span><span style="color:#657b83;">= </span><span style="color:#6c71c4;">1.</span><span style="color:#839496;">;
        </span><span style="color:#859900;">if </span><span style="color:#839496;">(</span><span style="color:#859900;">abs</span><span style="color:#839496;">(st </span><span style="color:#657b83;">- </span><span style="color:#6c71c4;">1.</span><span style="color:#839496;">) </span><span style="color:#657b83;">&lt; </span><span style="color:#6c71c4;">0.01 </span><span style="color:#657b83;">&amp;&amp;</span><span style="color:#839496;"> local_position.</span><span style="color:#268bd2;">y </span><span style="color:#657b83;">&lt; -</span><span style="color:#6c71c4;">0.5</span><span style="color:#839496;">) { </span><span style="color:#586e75;">// in SDF space
</span><span style="color:#839496;">            discard;
        } </span><span style="color:#859900;">else if </span><span style="color:#839496;">(</span><span style="color:#859900;">abs</span><span style="color:#839496;">(st </span><span style="color:#657b83;">- </span><span style="color:#6c71c4;">2.</span><span style="color:#839496;">) </span><span style="color:#657b83;">&lt; </span><span style="color:#6c71c4;">0.01 </span><span style="color:#657b83;">&amp;&amp;</span><span style="color:#839496;"> local_position.</span><span style="color:#268bd2;">y </span><span style="color:#657b83;">&gt; </span><span style="color:#6c71c4;">0.5</span><span style="color:#839496;">) {
            discard;
        }
        </span><span style="color:#859900;">if </span><span style="color:#839496;">(d </span><span style="color:#657b83;">&gt;</span><span style="color:#839496;"> edge1) {
            smooth </span><span style="color:#657b83;">= </span><span style="color:#6c71c4;">1. </span><span style="color:#657b83;">- </span><span style="color:#268bd2;">smoothstep</span><span style="color:#839496;">(edge1, edge2, d) </span><span style="color:#657b83;">+</span><span style="color:#839496;"> st </span><span style="color:#657b83;">-</span><span style="color:#839496;"> st;
        }
        vec4 color </span><span style="color:#657b83;">=</span><span style="color:#839496;"> color;
        color.</span><span style="color:#268bd2;">a </span><span style="color:#657b83;">=</span><span style="color:#839496;"> smooth;
        gl_FragColor </span><span style="color:#657b83;">=</span><span style="color:#839496;"> color;
    } </span><span style="color:#859900;">else </span><span style="color:#839496;">{
        gl_FragColor </span><span style="color:#657b83;">= </span><span style="color:#268bd2;">vec4</span><span style="color:#839496;">(color.</span><span style="color:#268bd2;">xyz</span><span style="color:#839496;">, </span><span style="color:#6c71c4;">0.0</span><span style="color:#839496;">);
    }
}
</span></pre>
<p>First, we do the same operation (create vertex position in world space) as in
vertex shader, but without projection with MVP matrix.
Then we calculate the distance to the borders with our line SDF function.
After that, we want to create a nice antialiased edge.
We pass the distance smoothstep function between <code>edge1</code> and <code>edge2</code> and then
pass the result value to the alpha channel of the result line's color.</p>
<p>But what is the segment type (st)?
In order to draw monochromatic polygonal chains with multiple segments we can't
just draw segments with corners on the top of each other.
Because if we do so then our smooth edges will overlap and blend with each other.
Maybe one can solve it with rendering to a texture or some nonstandard blending.
But we will just draw only one segment edge as shown in this picture
<img src="https://vladjuckov.github.io/hqlines/overlap.jpg" alt="overlap" />
(note that each line has a different color only for demonstration.
We can draw a red line on the top of the yellow. Or clip red line instead of yellow)</p>
<p>We have <code>segment type</code> which is a float variable but encodes discrete values
(Maybe I'm missing something
but it's not clear for me how to pass int variables into glsl shaders...
at least for this glsl version:) ):</p>
<ol start="0">
<li>Just draw regular segment</li>
<li>Cut the first end of the segment</li>
<li>Cut the second end of the segment</li>
</ol>
<pre style="background-color:#002b36;">
<span style="color:#859900;">if </span><span style="color:#839496;">(</span><span style="color:#859900;">abs</span><span style="color:#839496;">(st </span><span style="color:#657b83;">- </span><span style="color:#6c71c4;">1.</span><span style="color:#839496;">) </span><span style="color:#657b83;">&lt; </span><span style="color:#6c71c4;">0.01 </span><span style="color:#657b83;">&amp;&amp;</span><span style="color:#839496;"> local_position.</span><span style="color:#268bd2;">y </span><span style="color:#657b83;">&lt; -</span><span style="color:#6c71c4;">0.5</span><span style="color:#839496;">) { </span><span style="color:#586e75;">// in SDF space
</span><span style="color:#839496;">    discard;
} </span><span style="color:#859900;">else if </span><span style="color:#839496;">(</span><span style="color:#859900;">abs</span><span style="color:#839496;">(st </span><span style="color:#657b83;">- </span><span style="color:#6c71c4;">2.</span><span style="color:#839496;">) </span><span style="color:#657b83;">&lt; </span><span style="color:#6c71c4;">0.01 </span><span style="color:#657b83;">&amp;&amp;</span><span style="color:#839496;"> local_position.</span><span style="color:#268bd2;">y </span><span style="color:#657b83;">&gt; </span><span style="color:#6c71c4;">0.5</span><span style="color:#839496;">) {
    discard;
}
</span></pre>
<p>We draw a polygonal chain like this:</p>
<pre style="background-color:#002b36;">
<span style="color:#859900;">for</span><span style="color:#839496;"> i </span><span style="color:#859900;">in </span><span style="color:#6c71c4;">0</span><span style="color:#859900;">..</span><span style="color:#839496;">stringline_num {
    </span><span style="color:#268bd2;">let</span><span style="color:#839496;"> point </span><span style="color:#859900;">= vec2</span><span style="color:#839496;">(qrand::gen_range(</span><span style="color:#859900;">-</span><span style="color:#6c71c4;">100.</span><span style="color:#839496;">, </span><span style="color:#6c71c4;">100.</span><span style="color:#839496;">), qrand::gen_range(</span><span style="color:#859900;">-</span><span style="color:#6c71c4;">100.</span><span style="color:#839496;">, </span><span style="color:#6c71c4;">100.</span><span style="color:#839496;">));
    </span><span style="color:#268bd2;">let</span><span style="color:#839496;"> segment_type </span><span style="color:#859900;">= match</span><span style="color:#839496;"> i {
        </span><span style="color:#6c71c4;">0 </span><span style="color:#859900;">=&gt; </span><span style="color:#839496;">SegmentType::All,
        </span><span style="color:#859900;">_ =&gt; </span><span style="color:#839496;">SegmentType::NoFirst,
    };
    lines.</span><span style="color:#859900;">add</span><span style="color:#839496;">(Line::new(segment_type, prev, point, </span><span style="color:#cb4b16;">THICKNESS</span><span style="color:#839496;">, color));
    prev </span><span style="color:#859900;">=</span><span style="color:#839496;"> point;
}
</span></pre>
<p>This will produce cutting like a yellow line on the picture.</p>
<p>Our end result will look like this nice monochromatic polygonal lines:
<img src="https://vladjuckov.github.io/hqlines/random_lines.png" alt="random lines" /></p>
<h3 id="bonus-drawing-maps">Bonus: Drawing maps</h3>
<p>We can use our lib for example to draw the map.
I've provided some OSM data <a href="https://drive.google.com/file/d/16wjW3wh0f_nt9-J1ninXNTQwgeAVSawL/view?usp=sharing">here</a>.
We just import all data that can be represented
as segments and voila here is the map :)</p>
<p><img src="https://vladjuckov.github.io/hqlines/map.gif" alt="map" /></p>
</div>

  <p class="meta">Posted on <span class="postdate">2020-09-26</span></p>
</article>

      </div>
      <footer id="footer">
        <p class="copyright">
          
            Powered by <a href="https://www.getzola.org/">Zola</a> and the
            <a href="https://github.com/hulufei/solar-theme-zola">Solar</a>-theme.
          
        </p>
      </footer>
    </div>
  </body>
</html>
