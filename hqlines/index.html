<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">

    <!-- Enable responsiveness on mobile devices-->
    <!-- viewport-fit=cover is to support iPhone X rounded corners and notch in landscape-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, viewport-fit=cover">

    <title>Vlad Jukov&#x27;s blog</title>

    <!-- CSS -->
    
    <link rel="stylesheet" href="https:&#x2F;&#x2F;vladjuckov.github.io&#x2F;colors-dark.css">
    
    

    

    
    
  </head>
  <body>
    <header id="header">
      <h1><a href="https:&#x2F;&#x2F;vladjuckov.github.io&#x2F;">Vlad Jukov&#x27;s blog</a></h1>
      <p>About graphics programming</p>
    </header>
    <div id="page">
      <div id="sidebar">
        
          
        
      </div>
      <div id="content">
        
<article class="post">
  <h1><a href="https:&#x2F;&#x2F;vladjuckov.github.io&#x2F;hqlines&#x2F;">Is it easy to draw a line</a></h1>

  <div class="post-content"><!-- ![lines_square](lines_square.jpg) -->
<p><a href="https://pum-purum-pum-pum.github.io/lines/">Demo</a> Note for some reason on web
it's not that good as on desktop. I also had to turn off browsers AA manually.</p>
<p><a href="https://github.com/pum-purum-pum-pum/Lines">Source code</a></p>
<h3 id="wait-what">Wait what?</h3>
<p>If you just draw rectangle in OpenGL you'll
notice that the edges look like a pixel ladder.
You may try to fix that with MSAA but it's still poor quality.
Also one may want to draw the line not as a rectangle but as a rounded rectangle.</p>
<p><img src="https://vladjuckov.github.io/hqlines/line.gif" alt="line" /></p>
<p><a href="https://www.displaydaily.com/?view=article&amp;id=102:antialiasing&amp;catid=118:word-of-the-week">picture reference</a></p>
<h3 id="normal-width">Normal + width</h3>
<p>To draw just rectangle lines one can use normal to a segment as a vertex attribute.
This approach is well described <a href="https://blog.mapbox.com/drawing-antialiased-lines-with-opengl-8766f34192dc">here</a></p>
<h3 id="sdf">SDF</h3>
<p>The other way of drawing high quality segments is using Signed Distance Field (SDF).
We can create smooth edges by calculating the distance to it.
Also, with SDF we can create a nice rounded segment's ends.</p>
<p>We also want to draw polygonal chains.
Unfortunately, we can't just draw these segments on the top of each other,
because of transparent edges that will overlap and create ugly blending effect.
Or if the line itself is transparent we will just see overlaps.
It can be solved with rendering to texture for example.</p>
<p>We will only consider opaque lines.</p>
<p><a href="https://www.shadertoy.com/view/Wlfyzl">Here</a>
is the shader we will use for the segment's SDF.</p>
<pre style="background-color:#002b36;">
<span style="color:#839496;">float </span><span style="color:#859900;">line_segment</span><span style="color:#839496;">(</span><span style="color:#859900;">in</span><span style="color:#839496;"> vec2 p, </span><span style="color:#859900;">in</span><span style="color:#839496;"> vec2 a, </span><span style="color:#859900;">in</span><span style="color:#839496;"> vec2 b) {
    vec2 ba </span><span style="color:#859900;">=</span><span style="color:#839496;"> b </span><span style="color:#859900;">-</span><span style="color:#839496;"> a;
    vec2 pa </span><span style="color:#859900;">=</span><span style="color:#839496;"> p </span><span style="color:#859900;">-</span><span style="color:#839496;"> a;
    float h </span><span style="color:#859900;">= clamp</span><span style="color:#839496;">(</span><span style="color:#859900;">dot</span><span style="color:#839496;">(pa, ba) </span><span style="color:#859900;">/ dot</span><span style="color:#839496;">(ba, ba), </span><span style="color:#6c71c4;">0.</span><span style="color:#839496;">, </span><span style="color:#6c71c4;">1.</span><span style="color:#839496;">);
    </span><span style="color:#859900;">return length</span><span style="color:#839496;">(pa </span><span style="color:#859900;">-</span><span style="color:#839496;"> h </span><span style="color:#859900;">*</span><span style="color:#839496;"> ba);
}
</span><span style="color:#859900;">...
</span><span style="color:#586e75;">// later used like
</span><span style="color:#839496;">lowp float distance </span><span style="color:#859900;">= line_segment</span><span style="color:#839496;">(pp, a, b) </span><span style="color:#859900;">-</span><span style="color:#839496;"> thickness;
</span></pre>
<p>As you can see- in fragment shader we would need segment's ends and thickness.
That's why we need to pass these parameters as vertex attributes in the vertex
shader and then into fragment shader.
There are two ways that come to my head to do this:</p>
<ol>
<li>Create a buffer with two triangles for each line.
Just pass SDF parameters in each Vertex.</li>
<li>Only create one buffer for a line with two triangles and pass
these parameters per line via instancing.</li>
</ol>
<p>Our line struct will look like this. (segment type is actually discrete value)</p>
<pre style="background-color:#002b36;">
<span style="color:#839496;">#[</span><span style="color:#268bd2;">derive</span><span style="color:#839496;">(Debug, Clone, Copy)]
#[</span><span style="color:#268bd2;">repr</span><span style="color:#839496;">(C)]
</span><span style="color:#859900;">pub </span><span style="color:#268bd2;">struct </span><span style="color:#839496;">Line {
    </span><span style="color:#859900;">pub </span><span style="color:#268bd2;">segment_type</span><span style="color:#839496;">: </span><span style="color:#268bd2;">f32</span><span style="color:#839496;">,
    </span><span style="color:#859900;">pub </span><span style="color:#268bd2;">position</span><span style="color:#839496;">: Vec2,
    </span><span style="color:#859900;">pub </span><span style="color:#268bd2;">thickness</span><span style="color:#839496;">: </span><span style="color:#268bd2;">f32</span><span style="color:#839496;">,
    </span><span style="color:#859900;">pub </span><span style="color:#268bd2;">dir</span><span style="color:#839496;">: Vec2,
    </span><span style="color:#859900;">pub </span><span style="color:#268bd2;">color</span><span style="color:#839496;">: Vec3,
}

</span><span style="color:#268bd2;">impl </span><span style="color:#839496;">Line {
    </span><span style="color:#859900;">pub </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">new</span><span style="color:#839496;">(
        </span><span style="color:#268bd2;">segment_type</span><span style="color:#839496;">: SegmentType,
        </span><span style="color:#268bd2;">from</span><span style="color:#839496;">: Vec2,
        </span><span style="color:#268bd2;">to</span><span style="color:#839496;">: Vec2,
        </span><span style="color:#268bd2;">thickness</span><span style="color:#839496;">: </span><span style="color:#268bd2;">f32</span><span style="color:#839496;">,
        </span><span style="color:#268bd2;">color</span><span style="color:#839496;">: Vec3,
    ) -&gt; </span><span style="color:#268bd2;">Self </span><span style="color:#839496;">{
        </span><span style="color:#268bd2;">let</span><span style="color:#839496;"> dir </span><span style="color:#859900;">=</span><span style="color:#839496;"> to </span><span style="color:#859900;">-</span><span style="color:#839496;"> from;
        Line {
            segment_type: segment_type </span><span style="color:#859900;">as </span><span style="color:#268bd2;">u8 </span><span style="color:#859900;">as </span><span style="color:#268bd2;">f32</span><span style="color:#839496;">, </span><span style="color:#586e75;">// dirty hack to make OpenGL happy
</span><span style="color:#839496;">            position: (from </span><span style="color:#859900;">+</span><span style="color:#839496;"> to) </span><span style="color:#859900;">/ </span><span style="color:#6c71c4;">2.</span><span style="color:#839496;">,
            thickness,
            dir,
            color,
        }
    }
}
</span></pre><h3 id="shaders">Shaders</h3>
<p>I'm not sure if the second is faster (since the instance is only two triangles --
it's a small overhead).
But it's convenient and fast enough
to draw million of antialiased high-quality lines.</p>
<p>Here is the vertex shader code (sorry for the old glsl version):</p>
<pre style="background-color:#002b36;">
<span style="color:#839496;">#version 100
attribute vec2 pos;
attribute float segment_type;
attribute vec2 inst_pos;
attribute float thickness;
attribute vec2 dir;
attribute vec3 color0;

varying lowp vec2 local_position;
varying lowp vec2 projected_position;
varying lowp vec2 ip;
varying lowp float th;
varying lowp vec4 color;
varying lowp float st;
varying lowp vec2 dr;

uniform mat4 mvp;
void main() {
    vec2 n = vec2(-dir.y, dir.x) / length(dir);
    vec2 apos = pos.y * dir + pos.x * n * thickness;
    vec4 new_pos = vec4(apos + inst_pos, 0.0, 1.0);
    lowp vec4 res_pos = mvp * new_pos;
    gl_Position = res_pos;

    st = segment_type;
    local_position = pos;
    projected_position = vec2(new_pos.x, new_pos.y);
    ip = inst_pos;
    dr = dir;
    th = thickness;
    color = vec4(color0, 0.5);
}
</span></pre>
<p>We just change the shape of our line according to parameters:</p>
<ul>
<li>dir: segment direction</li>
<li>thickness: thickness of the line</li>
</ul>
<p>and then pass required variables into the fragment shader</p>
<p>Here is the fragment shader:</p>
<pre style="background-color:#002b36;">
<span style="color:#839496;">#version 100
varying lowp vec2 local_position;
varying lowp vec2 projected_position;
varying lowp vec2 ip;
varying lowp float th;
varying lowp vec4 color;
varying lowp float st;
varying lowp vec2 dr;

uniform highp mat4 mvp;
const lowp float aaborder = 0.00245;

lowp float line_segment(in lowp vec2 p, in lowp vec2 a, in lowp vec2 b) {
    lowp vec2 ba = b - a;
    lowp vec2 pa = p - a;
    lowp float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);
    return length(pa - h * ba);
}

void main() {
    lowp vec2 a = ip - dr  / 2.;
    lowp vec2 b = ip + dr / 2.;
    lowp float d = line_segment(projected_position, a, b) - th ;
    lowp float scaled_border = aaborder / mvp[0][0];
    lowp float edge1 = -scaled_border;
    lowp float edge2 = 0.;

    if (d &lt; 0.) {
        lowp float smooth = 1.;
        if (abs(st - 1.) &lt; 0.01 &amp;&amp; local_position.y &lt; -0.5) { // in SDF space
            discard;
        } else if (abs(st - 2.) &lt; 0.01 &amp;&amp; local_position.y &gt; 0.5) {
            discard;
        }
        if (d &gt; edge1) {
            smooth = 1. - smoothstep(edge1, edge2, d) + st - st;
        }
        lowp vec4 color = color;
        color.a = smooth;
        gl_FragColor = color;
    } else {
        gl_FragColor = vec4(color.xyz, 0.0);
    }
}
</span></pre>
<p>First, we do the same operation (create vertex position in world space) as in
vertex shader, but without projection with MVP matrix.
Then we calculate the distance to the borders with our line SDF function.
After that, we want to create a nice antialiased edge.
We pass the distance smoothstep function between <code>edge1</code> and <code>edge2</code> and then
pass the result value to the alpha channel of the result line's color.</p>
<p>In order to draw monochromatic polygonal chains with multiple segments we can't
just draw segments with corners on the top of each other.
Because if we do so then our smooth edges will overlap and blend with each other.
Maybe one can solve it with rendering to a texture or some nonstandard blending.
But we will just draw only one segment edge as shown in this picture
<img src="https://vladjuckov.github.io/hqlines/overlap.jpg" alt="overlap" />
(note that each line has a different color only for demonstration.
We can draw a red line on the top of the yellow. Or clip red line instead of yellow)</p>
<p>We have <code>segment type</code> which is a float variable but encodes discrete values
(Maybe I'm missing something but it's not clear how to pass int variables,
maybe it's just version, haven't tried):</p>
<ol start="0">
<li>Just draw regular segment</li>
<li>Cut the first end of the segment</li>
<li>Cut the second end of the segment</li>
</ol>
<pre style="background-color:#002b36;">
<span style="color:#839496;">if (abs(st - 1.) &lt; 0.01 &amp;&amp; local_position.y &lt; -0.5) { // in SDF space
    discard;
} else if (abs(st - 2.) &lt; 0.01 &amp;&amp; local_position.y &gt; 0.5) {
    discard;
}
</span></pre>
<p>We draw a polygonal chain like this:</p>
<pre style="background-color:#002b36;">
<span style="color:#859900;">for</span><span style="color:#839496;"> i </span><span style="color:#859900;">in </span><span style="color:#6c71c4;">0</span><span style="color:#859900;">..</span><span style="color:#839496;">stringline_num {
    </span><span style="color:#268bd2;">let</span><span style="color:#839496;"> point </span><span style="color:#859900;">= vec2</span><span style="color:#839496;">(qrand::gen_range(</span><span style="color:#859900;">-</span><span style="color:#6c71c4;">100.</span><span style="color:#839496;">, </span><span style="color:#6c71c4;">100.</span><span style="color:#839496;">), qrand::gen_range(</span><span style="color:#859900;">-</span><span style="color:#6c71c4;">100.</span><span style="color:#839496;">, </span><span style="color:#6c71c4;">100.</span><span style="color:#839496;">));
    </span><span style="color:#268bd2;">let</span><span style="color:#839496;"> segment_type </span><span style="color:#859900;">= match</span><span style="color:#839496;"> i {
        </span><span style="color:#6c71c4;">0 </span><span style="color:#859900;">=&gt; </span><span style="color:#839496;">SegmentType::All,
        </span><span style="color:#859900;">_ =&gt; </span><span style="color:#839496;">SegmentType::NoFirst,
    };
    lines.</span><span style="color:#859900;">add</span><span style="color:#839496;">(Line::new(segment_type, prev, point, </span><span style="color:#cb4b16;">THICKNESS</span><span style="color:#839496;">, color));
    prev </span><span style="color:#859900;">=</span><span style="color:#839496;"> point;
}
</span></pre>
<p>This will produce cutting like a yellow line on the picture.</p>
<p>Our end result will look like this nice monochromatic polygonal lines:
<img src="https://vladjuckov.github.io/hqlines/random_lines.png" alt="random lines" /></p>
<h3 id="bonus-drawing-maps">Bonus: Drawing maps</h3>
<p>We can use our lib for example to draw the map.
I've provided some OSM data <a href="https://drive.google.com/file/d/16wjW3wh0f_nt9-J1ninXNTQwgeAVSawL/view?usp=sharing">here</a>.
We just import all data that can be represented
as segments and voila here is the map :)</p>
<p><img src="https://vladjuckov.github.io/hqlines/map.gif" alt="map" /></p>
</div>

  <p class="meta">Posted on <span class="postdate">2020-09-14</span></p>
</article>

      </div>
      <footer id="footer">
        <p class="copyright">
          
            Powered by <a href="https://www.getzola.org/">Zola</a> and the
            <a href="https://github.com/hulufei/solar-theme-zola">Solar</a>-theme.
          
        </p>
      </footer>
    </div>
  </body>
</html>
